<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head><title>Maple Reference Documentation</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<link rel="stylesheet" href="minimal.css" type="text/css">
</head><body> 
<!-- minimalist html; this is designed to be copy/pasted into a website -->
<!-- STARTDOC -->
<h1>Maple Reference Documentation: Libraries</h1>
<p>
This page briefly summarizes the Arduino libraries that have been
ported to Maple.  You can use a library from within a sketch by going
to Sketch &gt; Import&nbsp;Library... from within the IDE, then
choosing the library you want.
</p>

<p>Any incompatibilities between the Maple and Arduino versions are
noted in the description of the library.
</p>

<ul>
  <li><a href="#liquidcrystal">LiquidCrystal</a></li>
  <li><a href="#wire">Wire</a></li>
</ul>

<h2><a name="liquidcrystal">LiquidCrystal</a></h2>
<p>
The LiquidCrystal library allows Maple to control LCD screens.  For
more information, see
the <a href="http://arduino.cc/en/Reference/LiquidCrystal">Arduino
LiquidCrystal</a> documentation.</p>

<h3>Compatibility Note</h3> 
<p>At this time, no incompatibilities between the Maple and Arduino
versions are known.  Any observed differences should be considered
bugs, and reported on
the <a href="http://forums.leaflabs.com/">forums</a>.</p>

<h2><a name="wire">Wire</a></h2>
<p>We provide a soft (bit-banged) implementation of
the <a href="http://arduino.cc/en/Reference/WireBegin">Wire I2C
library</a>.</p>

<h3>Compatibility Note</h3>
<p>This implementation is synchronous, and thus supports only a subset
of the full Wire interface (however, the functionality
which <em>is</em> supported is fully compatible with Arduino).  For
now, please use the function reference which follows when developing
projects using our implementation.</p>

<p>
Please note that the current implementation only supports master mode
using a bit-banged (software) protocol. Future enhancements will use
the hardware i2c peripheral on the stm32 as well as the DMA for
performance. Support for slave, smBUS, and multimaster modes are also
slated for inclusion in the enhanced Wire port.
</p>

<h3>Function Reference</h3>
<dl>
  <dt><code>Wire.begin()</code></dt>
  <dd>Joins the i2c bus as master, using pin 20 as SDA and pin 21 as
  SCL (this is compatible with the pin settings on the Arduino
  Mega).</dd>

  <dt><code>Wire.begin(sda, scl)</code></dt>
  <dd>Like <code>Wire.begin()</code>, but with the given pins as SDA
  and SCL.
  </dd>

  <dt><code>Wire.beginTransmission(slave_address)</code></dt>
  <dd>Set up a transmission to a slave device with the given 7-bit
  address.  Bytes subsequently queued for transmission
  (using <code>Wire.send</code>) will be sent
  to <code>slave_address</code> when <code>Wire.endTransmission</code>
  is called.</dd>

  <dt><code>Wire.send(byte)</code></dt>
  <dd>Queues the given byte (<code>int</code> or <code>uint8</code>)
    to the slave address previously specified by a call
    to <code>Wire.beginTransmission</code>.  At most 32 bytes may be
    queued in a single transmission.</dd>

  <dt><code>Wire.send(string)</code></dt>
  <dd>Queues a given string (<code>char*</code>) for transmission.
    The characters of the string are individually queued for
    transmission as bytes.  At most 32 bytes may be queued in a single
    transmission.</dd>

  <dt><code>Wire.send(buffer, length)</code></dt>
  <dd>Queues a byte buffer <code>buffer</code> (<code>int*</code>
  or <code>uint8*</code>), of length <code>length</code>, for
  transmission.  At most 32 bytes may be queued in a single
  transmission.</dd>

  <dt><code>Wire.endTransmission()</code></dt>
  <dd>Ends a transmission (begun
  by <code>Wire.beginTransmission</code>), and actually sends the
  bytes queued by calls to <code>Wire.send</code>.
    
    <p>The return value is one of the following status codes:
      <ul>
        <li><code>SUCCESS</code>: All bytes were transmitted
        successfully</li>

        <li><code>EDATA</code>: More than 32 bytes were queued for
        transmission.  No bytes are actually sent when this
        happens.</li>

        <li><code>ENACKADDR</code>: Did not receive ACK on transmit of
        address.  No bytes are actually sent when this happens.</li>

        <li><code>ENACKTRNS</code>: Did not receive ACK during
        transmit of data.  Some bytes may have been sent when this
        happens; however, the transmission is aborted after the first
        byte of data which is not ACKed by the slave device.</li>

        <li><code>EOTHER</code>: Other error occurred.</li>
      </ul>
    </p>
  </dd>

  <dt><code>Wire.requestFrom(address, num_bytes)</code></dt>
  <dd>Requests <code>num_bytes</code> bytes from 7-bit slave
  address <code>address</code>.  Returns the actual number of bytes
  read.  These bytes may subsequently be read one at a time
  using <code>Wire.receive()</code>.
  
  <p>
  Note: if <code>num_bytes</code> exceeds the size of the
  transmit/receive buffer (currently 32), it will be truncated to
  32.</p>
  </dd>

  <dt><code>Wire.receive()</code></dt>
  <dd>Get the next byte read during the previous call
  to <code>Wire.requestFrom</code>.  You can check how many bytes are
  left to read using <code>Wire.available()</code>.

  <dt><code>Wire.available()</code></dt>
  <dd>Returns the number of bytes which are still available for
  reading from the last call to <code>Wire.requestFrom</code>.</dd>

</dl>

<!-- ENDDOC -->
</body></html>
